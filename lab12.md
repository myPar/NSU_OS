### Лабораторная работа 12

#### Формулировка

Требуется доказать, что задача попеременного вывода родительской и дочерней ([задание 11](http://parallels.nsu.ru/WackoWiki/KursOperacionnyeSistemy/PraktikumPosixThreads/PthreadTasks?v=c9d)) нитей не может быть решена при помощи двух мьютексов, без использования других средств синхронизации.  

#### Ремарка

Очевидно, что если задача решается при помощи $n$ мьютексов, то она решается и при помощи $n+1$ мьютекса. Таким образом, доказательство будет строиться на том, что мы докажем, что задача не решается без использовния мьютексов, с использованием одного мьютекса и с использованием 2 мьютесов. Также, некоторые шаги в доказательстве будут опираться на предыдущие.  

#### Доказательство

Будем доказывать от противного. Рассмотрим каждый, вышеупомянутый вариант с предположением, что синхронизированную печать с указанным кол-вом мьютексов организовать всё-таки можно, и в каждом придём к противоречию.  

__мьютексов нет__

Очевидно, что секция печати строки является критической, если никакие примитивы синхронизации её не защищают, то никакой гарантии, что вывод потоков будет чередующимся нет. Таким образом без использования мьютексов и других примитивово синхронизации задачу решить нельзя.  

__мьютекс один__

Поскольку секция печати является критической, то её необходимо защитить примитивом синхронизации, в противном случае, несколько потоков смогут получить к ней доступ одновременно. В данном случае, для этого мы используем мьютекс. Один из потоков захватит мьютекс и произведёт печать. Когда данный поток освободит мьютекс нет никакой гарантии, что этот же поток не захватит его повторно и не произведёт повторную печать. Соответсвенно нет гарантии, что печать потоков будет чередующейся.  

__мьютекса два__

Здесь возможно несколько вариантов:

1. первый поток захватил мьютекс, второй не захватил никакой.
2. первый поток захватил оба мьютекса.
3. каждый поток захватил по одному мьютексу.

В первом варианте мы предполагаем, что второй поток не может захватить второй мьютекс, поскольку это уже будет 3 вариант. Первый поток может произвести печать, поскольку мьютекс, непосредственно защищающий критическую секции не заблокирован вторым потоком. Таким образом, первый поток производит печать, освобождает свой изначальный мьютекс и опять же, как и в предыдущем случае, нет никакой гарантии, что этот же поток не захватит мьютекс повторно и повторно не произведёт печать.  

Второй вариант более очевиден. Хозяин двух мьютексов произведёт печать, освободит один из мьютексов и мы сведёмся к рассмотрению первого варианта.  

Теперь рассмотрим третий вариант, когда каждый поток владеет одним мьютексом. В таком случае, один из потоков захватил мьютекс, непосредственно защищающий критическую секцию. Он произведёт печать. Для того, чтобы дать возможность напечатать строку второму потоку, единственное, что остаётся, это снять блокировку с мьютекса, защищающему секцию печати (второй мьютекс заблокирован другим потоком). Получается, мы приходим к ранее рассмотренному варианту, когда один из потоков не владеет никаким мьютексом, для которого мы выяснили, что синхронизированную печать организовать невозможно.  

Мы рассмотрели все варианты организации синхронизированной печати с кол-вом мьютексов 0-2 и для каждого доказали, что синхронизированную печать реализовать таким образом невозможно. Следовательно данная задача не решается с использованием двух мьютексов без использования других средств синхронизации.  